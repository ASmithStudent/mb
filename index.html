<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">  
    <meta name="description" content="Course page for Mission Bit at Gateway HS">
    <meta name="author" content="Greg Gorlen">
    <meta name="keywords" content="mission, bit, gateway">
    <title>Mission Bit at Gateway HS</title>

    <!-- Favicon -->
    <link rel="shortcut icon" href="favicon.ico" type="image/x-icon" />

    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

    <!-- CSS -->
    <link rel="stylesheet" href="css/style.css">

    <noscript>
      <style>body { display: block; opacity: 1; }</style>
    </noscript>

    <style>

      h1 {
        display: block;
        flex-shrink: 1;  // trying to fix wrapping in ie
        box-sizing: border-box; /* 2 */
        max-width: 100%; /* 1 */
      }

      html, body {
        height: 100%;
        user-select: none;
      }

      main {  
        flex: 1 0 0;
      }

      footer i {
        margin: 0.4em;
        color: #444;
      }

      footer a, 
      footer a:link,
      footer a:visited,
      footer a:hover,
      footer a:active,
      footer a:focus { 
        border: 0;
        font-size: 1em;
      }

      #wrapper {
       display: flex; flex-direction: column; align-items: center; flex-wrap: wrap; height: 100%;
      }

      @media screen and (max-width: 900px) {
        main {
          flex: 0 1 auto;
        }

        div#wrapper {
          height: 80%;
        }
      }


    </style>

  </head>

  <body>

    <nav>
      <a href="modules/">Modules</a>
      <a href="resources/">Resources</a>
      <a href="projects/">Projects</a>
      <a href="about/">About</a>
    </nav>

    <div id="wrapper">
      <main style="background: transparent; margin: 0;"> 
        <h1 style="color: #444;">Mission Bit at Gateway HS</h1>
      </main>

      <footer>
        <a href="https://www.github.com/ggorlen" title="github"><i class="fa fa-github fa-2x"></i></a>
        <a href="https://www.codepen.io/ggorlen/" title="codepen"><i class="fa fa-codepen fa-2x"></i></a>
      </footer>  
    </div>

    <!-- jQuery -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.2.0/jquery.min.js">
    </script>

    <!-- Global JS script -->
    <script src="js/global.js"></script>

<!--
    <script>
      "use strict";

      const canvas = document.createElement("canvas");
      canvas.width = parseInt(getComputedStyle(document.body).width);
      canvas.height = parseInt(getComputedStyle(document.body).height);
      document.body.appendChild(canvas);
      canvas.style.position = "absolute";
      canvas.style.top = 0;
      canvas.style.zIndex = -1;
      const ctx = canvas.getContext("2d");
      let handles = [];
      let handleQty;
      let handleSize;
      let friction;
      let spring;
      let springLength;
      let mouse;
      let draggingHandle;
      let timeout;

      const Handle = function (x, y, radius) {
        this.x = x;
        this.y = y;
        this.vx = 0;
        this.vy = 0;
        this.radius = radius;
      };

      const springTo = (a, b) => {
        const dx = b.x - a.x;
        const dy = b.y - a.y;
        const angle = Math.atan2(dy, dx);
        const targetX = b.x - Math.cos(angle) * springLength;
        const targetY = b.y - Math.sin(angle) * springLength;

        a.vx += (targetX - a.x) * spring;
        a.vy += (targetY - a.y) * spring;
        a.vx *= friction;
        a.vy *= friction;
        //a.vy += 0.05;
        a.x += a.vx;
        a.y += a.vy;

        //if (a.y <= canvas.height) {
       //   a.y += a.vy;
        //}
       // else {
       //   a.y = canvas.height;
       // }
      };

      const init = () => {
        canvas.width = parseInt(getComputedStyle(document.body).width);
        canvas.height = parseInt(getComputedStyle(document.body).height);
        ctx.lineWidth = 2;
        handles = [];
        handleQty = 10;
        handleSize = 60
        friction = 0.52;
        spring = 0.59;
        springLength = 100;
        mouse = { x: canvas.width / 2, y: canvas.height / 2 };
        draggingHandle = null;

        for (let i = 0; i < handleQty; i++) {
          handles.push(new Handle(
            Math.random() * canvas.width, 
            Math.random() * canvas.height, 
            handleSize
          ));
        }
      };

      const orientation = (p, q, r) => {
        const val = (q.y - p.y) * (r.x - q.x) - 
                    (q.x - p.x) * (r.y - q.y);
        return val === 0 ? 0 : ((val > 0) ? 1 : 2);
      };
      
      const jarvis = points => {
        const hull = [];
        const leftMost = points.reduce((a, e, i) => points[a].x < points[i].x ? a : i, 0);
        let q = 0;
        let p = leftMost;
        let endpoint;
        
        do {
          hull.push(points[p]);
          q = (p + 1) % points.length;
          
          for (let i = 0; i < points.length; i++) {
             const o = orientation(points[p], points[i], points[q]);
            
             if (o === 2) {
               q = i;
             }
          }
          
          p = q;
        } while (p !== leftMost);
        return hull;
      };

      window.addEventListener("resize", e => {
        clearTimeout(timeout);
        timeout = setTimeout(init, 600);
      });
      document.addEventListener("mousedown", e => {
        for (let i = 0; i < handles.length; i++) {
          if ((mouse.x - handles[i].x) * (mouse.x - handles[i].x) + 
              (mouse.y - handles[i].y) * (mouse.y - handles[i].y) <= 
               handles[i].radius * handles[i].radius) {
            e.preventDefault();
            draggingHandle = handles[i];
            break;
          }
        }
      });
      document.addEventListener("mouseup", e => draggingHandle = null);
      document.addEventListener("mousemove", e => mouse = { x: e.pageX, y: e.pageY });

      init();


      (function update() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        // ctx.globalCompositeOperation = "source-over";
        // ctx.fillStyle = "rgba(255, 255, 255, 0.2)";
        // ctx.fillRect(0, 0, canvas.width, canvas.height);
  
        //ctx.shadowBlur = 5;
        //ctx.shadowColor = "#999";

        for (let i = 0; i < handles.length; i++) {
          springTo(handles[i], handles[(i+1)%handles.length]);
        }

        if (draggingHandle) {
          //const dx = mouse.x - draggingHandle.x;
          //const dy = mouse.y - draggingHandle.y;
          draggingHandle.x = mouse.x
          draggingHandle.y = mouse.y
        }

        ctx.fillStyle = "#333";
        handles.forEach(e => {
          ctx.beginPath();
          ctx.arc(e.x, e.y, 30, 0, Math.PI * 2);
          ctx.fill(); 
        });

        ctx.beginPath();
        jarvis(handles).forEach(e => ctx.lineTo(e.x, e.y));
        ctx.closePath();
        ctx.stroke();

        let inBounds = false;

        for (let i = 0; i < handles.length; i++) {
          if (handles[i].x > 0 && handles[i].y > 0 &&
              handles[i].x < canvas.width && 
              handles[i].y < canvas.height) {
            inBounds = true;
            break;
          }
        }

        if (!inBounds) { init(); }
        requestAnimationFrame(update);
      })();
    </script>
    -->

    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.12.0/matter.min.js"></script>

    <script>
      "use strict";

      const rad = d => d * Math.PI / 180;
      const canvas = document.createElement("canvas");
      canvas.width = parseInt(getComputedStyle(document.body).width);
      canvas.height = parseInt(getComputedStyle(document.body).height);
      canvas.style.position = "absolute";
      canvas.style.top = 0;
      canvas.style.zIndex = -1;
      document.body.appendChild(canvas);
      const ctx = canvas.getContext("2d");
      ctx.lineWidth = 5;
      
      const Engine = Matter.Engine;
      const World = Matter.World;
      const Vector = Matter.Vector;
      const Bodies = Matter.Bodies;
      const engine = Engine.create();
      const MouseConstraint = Matter.MouseConstraint;
      const mouseConstraint = MouseConstraint.create(engine);
      const setMouseOffset = () => {
        const rect = canvas.getBoundingClientRect();
        Matter.Mouse.setOffset(mouseConstraint.mouse, {
          x: -rect.x, y: -rect.y
        });
      };
      setMouseOffset();
      document.addEventListener("mousemove", e => 
        setTimeout(setMouseOffset, 500)
      );
      World.add(engine.world, mouseConstraint);
      
      // Create body arrays
      const boxes = [];
      const ledges = [
        Bodies.rectangle(
          canvas.width / 2, canvas.height, 
          canvas.width / 1.5, canvas.height / 4, 
          { isStatic: true }
        )
      ];
      //Matter.Body.rotate(ledges[0], rad(35));
      //Matter.Body.rotate(ledges[1], rad(-25));
      
      // Add bodies to the world
      World.add(engine.world, ledges);
      //Engine.run(engine); 
      
      const draw = (body, ctx) => {
        ctx.fillStyle = body.color || "#fff";
        ctx.beginPath();
        body.vertices.forEach(e => ctx.lineTo(e.x, e.y));
        ctx.closePath();
        ctx.stroke();
        ctx.fill();
      };
      
      const inBounds = (body, canvas) => {
        for (let i = 0; i < body.vertices.length; i++) {
          if (body.vertices[i].x < canvas.width &&
            body.vertices[i].x > 0 &&
            body.vertices[i].y < canvas.height //&&
            /*body.vertices[i].y > 0*/) {
            return true;
          }
        }
      
        return false;
      };
      
      (function update() {
        if ((boxes.length < 50 || Math.random() < 0.0001) && boxes.length < 500) {
          boxes.unshift(Bodies.rectangle(
            canvas.width / 2, -130, Math.random() * 50 + 5, 
            Math.random() * 50 + 5,
            { frictionAir: 0.01, friction: 0.1, restitution: 0.6 }
          ));
      
          boxes[0].color = "hsl(" + (Math.random() * 200 + 160) + ", 90%, 50%)";
          World.add(engine.world, [boxes[0]]);
          Matter.Body.rotate(boxes[0], rad(Math.random() * 360));
        }
      
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      
        for (let i = boxes.length - 1; i >= 0; i--) {
          draw(boxes[i], ctx);
      
          if (!inBounds(boxes[i], canvas)) {
            World.remove(engine.world, boxes[i]);
            boxes.splice(i, 1);
          }
        }
      
        ledges.forEach(e => draw(e, ctx));
        Engine.update(engine);  // instead of a single call to Engine.run(engine)
        requestAnimationFrame(update);
      })();
    </script>
  </body>
</html>
